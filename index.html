<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>Mio Micro</title>
	<script type='text/javascript' src='import.js'></script>
    <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: #fff; display: block; margin: 0 auto; }
    </style>
</head>
<body style='overflow:hidden'>

<canvas id='canvas' width='192' height='128' ondrop='drop_handler(event);' ondragover='drag_over_handler(event);'></canvas>

<script>

const BACKGROUND_WIDTH = 192;
const BACKGROUND_HEIGHT = 128;
const BACKGROUND_PIXEL_COUNT = BACKGROUND_WIDTH * BACKGROUND_HEIGHT;
const COLOUR_BYTES_COUNT = 4;
// TODO: Make algorithm that doesn't rely on luck
const MAX_BEFORE_GAME_JUMP_ATTEMPTS = 18;
const MAX_DURING_GAME_JUMP_ATTEMPTS = 6;


let canvas = document.getElementById('canvas');
let context = canvas.getContext('2d');

const ideal_canvas_width = 192;
const ideal_canvas_height = 128;

let scale = window_scale(window);
scale_canvas(scale);

function window_size(window) {
	return [window.innerWidth, window.innerHeight];
}

function window_scale(window) {
	let [width, height] = window_size(window);
	return Math.min(width / ideal_canvas_width, height / ideal_canvas_height);
	
}

function scale_canvas(scale) {
	canvas.width = ideal_canvas_width * scale;
	canvas.height = ideal_canvas_height * scale;
	context.scale(scale, scale);
	context.imageSmoothingEnabled = false;
}

window.addEventListener("resize", handleWindowResize, false)
function handleWindowResize(event) {
	scale = window_scale(window);
	scale_canvas(scale);
	if (mio_data == null) {
		context.drawImage(intro, 0, 0);
	}
}

let collision_canvas = document.createElement('canvas');
let collision_context = collision_canvas.getContext('2d');


// TODO:
let collision_pixels = [];

let intro = new Image();
intro.src = 'images/intro.png';

intro.onload = () => {
    context.drawImage(intro, 0, 0);   
}

let audio_names = [
	'explosion',
	'glass',
	'gong',
	'spring',
	'pistol',
	'slice',
	'camera',
	'splash',
	'correct',
	'incorrect',
	'switch',
	'input',
	'falling',
	'wiggle',
	'rising',
	'victory',
	'batting',
	'swing',
	'impact',
	'kick',
	'racquet',
	'bowling',
	'sunk_putt',
	'whistle',
	'frying_pan',
	'bell',
	'knife_chop',
	'mobile_phone',
	'razor',
	'mobile_phone',
	'popped_cork',
	'water',
	'sneeze',
	'snap',
	'munching',
	'gulp',
	'punch',
	'foot_stamp',
	'gasp',
	'applause',
	'cat',
	'big_dog',
	'pig',
	'small_dog',
	'wolf',
	'crow',
	'tiger',
	'wing_flap',
	'baby',
	'giggle',
	'scream',
	'too_bad',
	'kung_fu',
	'lets_fight',
	'cheering',
	'booing',
	'mario_jump',
	'coin',
	'power_up',
	'power_down',
	'shell_kick',
	'cannon',
	'struck',
	'barrel_hop',
];

let sounds = [];

const load_sound = (name) => {
	let audio = new Audio('sounds/' + name + '.ogg');
	audio.volume = 1;
	sounds.push(audio);
	return audio;
};

audio_names.forEach(name => {
	let audio = new Audio('sounds/' + name + '.ogg');
	audio.volume = 1;
	sounds.push(audio);
});

let win_sounds = [load_sound('win1'), load_sound('win2')];
let lose_sounds = [load_sound('lose1'), load_sound('lose2')];

let random_in_range = (min, max) => min + (max - min) * Math.random();
let random_int_in_range = (min, max) => Math.floor(random_in_range(min, max));
let random_in_array = (array) => array[random_int_in_range(0, array.length)];

function position_in_area(area, size) {
	let half_size = size / 2;
    let min_x = area.min.x + half_size;
    let max_x = area.max.x - half_size;
    let x;
	if (min_x > max_x) {
        x = (area.min.x + area.max.x) / 2;
    } else {
        x = random_int_in_range(min_x, max_x);
    };
    let min_y = area.min.y + half_size;
    let max_y = area.max.y - half_size;
    let y;
	if (min_y > max_y) {
        y = (area.min.y + area.max.y) / 2;
    } else {
        y = random_int_in_range(min_y, max_y);
    }
    return { x, y }
}

// TODO: Replace these with the correct values
function animation_time_from_speed(speed) {
	let time;
	/*let animation_times = {
		[Speed.Slowest]: 16
	*/
	switch (speed) {
		case Speed.Slowest: {
			time = 59;
			break;
		}
		case Speed.Slow: {
			time = 29;
			break;
		}
		case Speed.Normal: {
			time = 14;
			break;
		}
		case Speed.Fast: {
			time = 7;
			break;
		}
		case Speed.Fastest: {
			time = 3;
			break;
		}
		default: {
			console.warn('Unreachable animation time');
		}
	}
	return time;
};

function value_from_speed(speed) {
	let value;
	switch (speed) {
		case Speed.Slowest: {
			value = 0.5;
			break;
		}
		case Speed.Slow: {
			value = 1.0;
			break;
		}
		case Speed.Normal: {
			value = 1.5;
			break;
		}
		case Speed.Fast: {
			value = 3;
			break;
		}
		case Speed.Fastest: {
			value = 6;
			break;
		}
	}
	return value;
};

const ActiveTravel = {
	GoStraight: 'GoStraight',
	GoToPoint: 'GoToPoint',
	GoToObject: 'GoToObject',
	Roam: 'Roam',
	AttachTo: 'AttachTo',
	Stop: 'Stop',
	JumpToPosition: 'JumpToPosition',
	JumpToArea: 'JumpToArea',
	Swap: 'Swap'
};

const BounceDirection = {
	Left: 'Left',
	Right: 'Right',
	None: 'None'
};

let game_id = 0;
let mio_data = null;

window.addEventListener("keydown", event => {
  if (event.code === "KeyR" && mio_data !== null) {
	load_game(mio_data);
  }
}, true);

const bufferFromFile = (file) => {
	return new Promise((resolve, reject) => {
		let file_reader = new FileReader();
		
		file_reader.onload = () => {
			resolve(file_reader.result);
		};
		
		file_reader.onerror = reject;

		file_reader.readAsArrayBuffer(file);
	})
};

async function drop_handler(event) {
	console.log('File(s) dropped');

	event.preventDefault();

	if (event.dataTransfer.items) {
		for (let item = 0; item < event.dataTransfer.items.length; item++) {
			if (event.dataTransfer.items[item].kind === 'file') {
				const file = event.dataTransfer.items[item].getAsFile();
				console.log('file: ', file.name);
				let buffer = await bufferFromFile(file);
				mio_data = new Uint8Array(buffer);
				load_game(mio_data);
			}
			
		}
	} else {
		for (let i = 0; i < event.dataTransfer.files.length; i++) {
			console.warn('Not Implemented');
		}
	}
}

function load_game(data) {
	game_id++;
	let game_data = new GameData(data);
	console.log(game_data.name);
	
	let bg_offset = 0x100;
	let bg_length = 0x30FF - bg_offset;
	let scrambled_pixels = [];
	
	for (let i = bg_offset; i <= bg_offset + bg_length; i++) {
		scrambled_pixels.push(second_hex_digit(data[i]));
		scrambled_pixels.push(first_hex_digit(data[i]));
	}
	
	let pixel_value = pixel => {
		switch (pixel) {
			case 0x00: {
				return [0, 0, 0, 0];
			}
			case 0x01: {
				return [0, 0, 0, 255];
			}
			case 0x02: {
				return [255, 222, 156, 255];
			}
			case 0x03: {
				return [255, 173, 49, 255];
			}
			case 0x04: {
				return [198, 74, 0, 255];
			}
			case 0x05: {
				return [255, 0, 0, 255];
			}
			case 0x06: {
				return [206, 107, 239, 255];
			}
			case 0x07: {
				return [16, 198, 206, 255];
			}
			case 0x08: {
				return [41, 107, 198, 255];
			}
			case 0x09: {
				return [8, 148, 82, 255];
			}
			case 0x0A: {
				return [115, 214, 57, 255];
			}
			case 0x0B: {
				return [255, 255, 90, 255];
			}
			case 0x0C: {
				return [123, 123, 123, 255];
			}
			case 0x0D: {
				return [198, 198, 198, 255];
			}
			case 0x0E: {
				return [255, 255, 255, 255];
			}
			// TODO: Set 0x0F correctly
			case 0x0F: {
				return [0, 0, 255, 255];
			}
			default: {
				console.warn('Unreachable Pixel Colour', pixel);
			}
		}
	};
	
	let background_pixels = new Uint8ClampedArray(BACKGROUND_PIXEL_COUNT * COLOUR_BYTES_COUNT);
	
	for (let i = 0; i < BACKGROUND_PIXEL_COUNT; i++) {
		let block_size = 1536;
		let block_index = Math.floor(i / block_size);
		let internal_index = i % block_size;
		let grid_square_index = Math.floor(internal_index / 64);
		let grid_column_index = i % 8;
		let grid_row_index = Math.floor(internal_index / 8) % 8; // TODO:
		let column_index = (grid_square_index * 8 + grid_column_index);
		let row_index = (block_index * 8 + grid_row_index);
		
		let colour = pixel_value(scrambled_pixels[i]);
		
		for (let c = 0; c < colour.length; c++) {
			//let colour = [255, 0, 0, 255];
			let index = row_index * BACKGROUND_WIDTH + column_index;
			background_pixels[index * COLOUR_BYTES_COUNT + c] = colour[c];
		}
	}

	let background_image_data = context.createImageData(BACKGROUND_WIDTH, BACKGROUND_HEIGHT);
	background_image_data.data.set(background_pixels);
	
	let temp_canvas = document.createElement('canvas');
	let temp_context = temp_canvas.getContext('2d');

	temp_canvas.width = BACKGROUND_WIDTH;
	temp_canvas.height = BACKGROUND_HEIGHT;
	temp_context.putImageData(background_image_data, 0, 0);
	let background_image = new Image();
	background_image.src = temp_canvas.toDataURL();

	let images_offset = 0x3104;
	let images_length = 0xB103 - images_offset;
	let images_pixels = [];
	for (let i = images_offset; i <= images_offset + images_length; i++) {
		images_pixels.push(second_hex_digit(data[i]));
		images_pixels.push(first_hex_digit(data[i]));
	}
	
	let image_data = {};
	let collision_data = {};
	
	for (let i = 0; i < OBJECT_COUNT; i++) {
		let object = game_data.object(i);
		if (!object.is_active) {
			continue;
		}
		
		let size = object.sprite_size;
		
		for (let j = 0; j < ART_BANK_COUNT; j++) {
			let art = object.art(j);
			if (!art.is_active) {
				continue;
			}
			let bank = art.bank;
			for (let b = 0; b < bank.length; b++) {
				let grid_width = 8;
				let grid_height = 8;
				let grids_used;
				let grid_multiplier = 4;
				switch (size) {
					case 16: {
						grids_used = 1 * grid_multiplier;
						break;
					}
					case 32: {
						grids_used = 4 * grid_multiplier;
						break;
					}
					case 48: {
						grids_used = 9 * grid_multiplier;
						break;
					}
					case 64: {
						grids_used = 16 * grid_multiplier;
						break;
					}
					default: {
						console.warn('Unreachable Size');
					}
				}
				
				let first_grid = bank[b] * 4;
				let first_pixel_index = first_grid * grid_width * grid_height;
				let total_pixel_count = grids_used * grid_width * grid_height;
				
				let image = context.createImageData(size, size);
				let collision_image = context.createImageData(size, size);
				for (let index = 0; index < total_pixel_count; index++) {
					let pixel = images_pixels[first_pixel_index + index];
					let grid = Math.floor(index / 64);
					let internal_grid_index = index % 64;
					let grid_column_index = index % 8;
					let grid_row_index = Math.floor(internal_grid_index / 8);
					let grid_base_x = grid % Math.floor(size / 8);
					let grid_base_y = Math.floor(grid / Math.floor(size / 8));
					let column_index = grid_base_x * 8 + grid_column_index;
					let row_index = grid_base_y * 8 + grid_row_index;
					
					let colour = pixel_value(pixel);
					
					for (let c = 0; c < colour.length; c++) {
						let pixel_index = row_index * size + column_index;
						image.data[pixel_index * COLOUR_BYTES_COUNT + c] = colour[c];
						let paste;
						if (c < 3) {
							paste = i;
						} else {
							paste = colour[c];
						}
						collision_image.data[pixel_index * COLOUR_BYTES_COUNT + c] = paste;
					}
				}
				let temp_canvas = document.createElement('canvas');
				let temp_context = temp_canvas.getContext('2d');

				temp_canvas.width = size;
				temp_canvas.height = size;
				temp_context.putImageData(image, 0, 0);
				let sprite = new Image();
				sprite.src = temp_canvas.toDataURL();
				image_data[bank[b]] = sprite;
				collision_data[bank[b]] = collision_image.data;
				let collision_sprite = new Image();
				temp_context.putImageData(collision_image, 0, 0);
				collision_sprite.src = temp_canvas.toDataURL();
				collision_data[bank[b]].sprite = collision_sprite;
			}
		}
	}
	
	let win_conditions = [];

	for (let i = 0; i < WIN_CONDITIONS_COUNT; i++) {
		win_conditions.push([]);
		for (let j = 0; j < SWITCH_CONDITIONS_COUNT; j++) {
			let condition = game_data.win_condition(i, j);
			if (condition !== null) {
				win_conditions[i].push(condition);
			}
		}
	}
	console.log(win_conditions);
	
	let length = game_data.length;
	
	let objects = [];
	
	for (let i = 0; i < OBJECT_COUNT; i++) {
		let object = game_data.object(i);
		
		if (object.is_active) {
			let art_set = [];
			for (let a = 0; a < OBJECT_ART_COUNT; a++) {
				let art = object.art(a);
				if (art.is_active) {
					let bank = art.bank;
					
					// TODO:
					let leftest = null;
					let rightest = null;
					let toppest = null;
					let bottomest = null;
					let size = object.sprite_size;
					let total_pixel_count = size * size;
					for (let b = 0; b < bank.length; b++) {
						let collision_image = collision_data[bank[b]];
						for (let index = 0; index < total_pixel_count; index++) {
							// TODO:
							let alpha = collision_image[index * COLOUR_BYTES_COUNT + 3];
							if (alpha !== 0) {
								let row_index = index % size;
								let column_index = Math.floor(index / size);
								if (leftest === null) {
									leftest = row_index;
									rightest = row_index;
									toppest = column_index;
									bottomest = column_index;
								} else {
									leftest = Math.min(leftest, row_index);
									rightest = Math.max(rightest, row_index);
									toppest = Math.min(toppest, column_index);
									bottomest = Math.max(bottomest, column_index);
								}
							}
						}
					}
					let collision_area = {
						min: {
							x: leftest,
							y: toppest
						},
						max: {
							x: rightest,
							y: bottomest
						}
					};
					
					art_set.push({ name: art.name, bank, collision_area });
				} else {
					art_set.push(null);
				}
			}
			
			let assembly = object.assembly;
			
			if (assembly.is_active) {
				let start_instruction = assembly.start_instruction;
			
				let instructions = [];
				
				for (let ins = 0; ins < INSTRUCTION_COUNT; ins++) {
					let instruction = assembly.instruction(ins);
					if (instruction.is_active) {
						let triggers = [];
						for (let t = 0; t < TRIGGER_COUNT; t++) {
							let trigger = instruction.trigger(t);
							if (trigger !== null) {
								triggers.push(trigger);
							}
						}
						let actions = [];
						for (let a = 0; a < ACTION_COUNT; a++) {
							let action = instruction.action(a);
							if (action !== null) {
								actions.push(action);
							}
						}
						instructions.push({ triggers, actions });
					}
				}
			
				objects.push({
					name: object.name,
					sprite_size: object.sprite_size,
					art: art_set,
					start_instruction,
					instructions,
				});
			} else {
				objects.push(null);
			}
		} else {
			objects.push(null);
		}
	}
	
	console.log(objects);
	
	let layers = [];
	
	for (let layer = 0; layer < objects.length; layer++) {
		// TODO: Verify this
		let index = data[0xE5F6 + objects.length - layer - 1];
		layers.push(index);
	}
	
	console.log(JSON.stringify({ length, objects, win_conditions, layers }, null, 4));
	
	let properties = [];
	
	for (let i = 0; i < objects.length; i++) {
		if (objects[i] === null) {
			properties.push(null);
			continue;
		}
		let location = objects[i].start_instruction.location;
		let size = objects[i].sprite_size;
		let position = null;
		let travel = [{ tag: ActiveTravel.Stop }];
		
		let start_art =  objects[i].start_instruction.art;
		let art_index = start_art.index;
		let art = objects[i].art[art_index];
		let bank_index = art.bank[0];
		
		properties.push({
			position,
			size,
			art: {
				bank_index,
				art_index,
				style: start_art.style,
				speed: start_art.speed,
				finished_playing: false,
				animation_index: 0,
				time_to_next_change: animation_time_from_speed(start_art.speed)
			},
			travel,
			switch_state: SwitchWhen.IsOff,
			next_switch_state: SwitchWhen.IsOff,
			touched_previous_frame: [],
			done_time_triggers: []
		});
	}
	
	for (let i = 0; i < objects.length; i++) {
		if (objects[i] === null) {
			continue;
		}
		let location = objects[i].start_instruction.location;
		let size = objects[i].sprite_size;
		let props = properties[i];
		if (location.tag == StartLocation.Position) {
			props.position = clone_position(location.position);
		} else if (location.tag == StartLocation.Area) {
			let area = clone_area(location.area);
			let art_index = props.art.art_index;
			let collision_area = objects[i].art[art_index].collision_area;
			area.min.x -= collision_area.min.x;
			area.min.y -= collision_area.min.y;
			area.max.x += props.size - collision_area.max.x;
			area.max.y += props.size - collision_area.max.y;
			if (location.overlap === Overlap.Anywhere) {
				props.position = position_in_area(area, size);
			} else {
				attempt_to_jump(properties, i, area, collision_data, MAX_BEFORE_GAME_JUMP_ATTEMPTS);
			}
		} else if (location.tag == StartLocation.AttachToObject) {
			props.travel = [{
				tag: ActiveTravel.AttachTo,
				index: location.index,
				offset: location.offset
			}];
		}
	}
	
	// Should work without this, but should stop it from getting stuck in exceptional circumstances
	let tries = 50;
	// TODO: Do this recursively instead
	while (properties.some(p => p !== null && p.position === null) && tries >= 0) {
		tries--;
		for (let i = 0; i < objects.length; i++) {
			if (objects[i] === null) {
				continue;
			}
			let location = objects[i].start_instruction.location;
			let props = properties[i];
			if (location.tag == StartLocation.AttachToObject && props.position === null) {
				let other_index = location.index;
				if (properties[other_index].position !== null) {
					props.position = clone_position(properties[other_index].position);
					props.position.x += location.offset.x;
					props.position.y += location.offset.y;
				}
			}
		}
	}
	
	console.log(properties);
	
	requestAnimationFrame(() => {
		run_frame(
			{ id: game_id, length, objects, win_conditions, layers, collision_data },
			{ properties, win_status: GameCondition.NotYetWon, frame: 0, time: 0, last_timestamp: null, is_frozen: false },
			{ image_data, background_image }
		);
	})
}

const ButtonState = {
	Up: 'Up',
	Release: 'Release',
	Down: 'Down',
	Press: 'Press'
};

let mouse = {
	x: 0,
	y: 0,
	state: ButtonState.Up,
};

document.addEventListener('mousemove', handle_mouse_move, false);
document.addEventListener('mousedown', handle_mouse_down, false);
document.addEventListener('mouseup', handle_mouse_up, false)

let mouse_down = false;

function handle_mouse_move(event) {
	mouse.x = Math.floor((event.clientX - canvas.offsetLeft) / scale);
	mouse.y = Math.floor((event.clientY - canvas.offsetTop) / scale);
}

function handle_mouse_down(event) {
	if (event.button === 0) {
		mouse_down = true;
	}
}

function handle_mouse_up(event) {
	if (event.button === 0) {
		mouse_down = false;
	}
}

function are_touching(properties, index, other_index, collision_data) {
	let props = properties[Math.min(index, other_index)];
	let size = props.size;
	let half_size = size / 2;
	let area_from_properties = props => {
		let size = props.size;
		let half_size = size / 2;
		return {
			min: {
				x: props.position.x - half_size,
				y: props.position.y - half_size
			},
			max: {
				x: props.position.x + half_size,
				y: props.position.y + half_size
			}
		};
	};
	let area = area_from_properties(props);
	let other_props = properties[Math.max(index, other_index)];
	let other_size = other_props.size;
	let other_half_size = other_size / 2;
	let other_area = area_from_properties(other_props);
	let common_area = {
		min: {
			x: Math.floor(Math.max(area.min.x, other_area.min.x)),
			y: Math.floor(Math.max(area.min.y, other_area.min.y))
		},
		max: {
			x: Math.floor(Math.min(area.max.x, other_area.max.x)),
			y: Math.floor(Math.min(area.max.y, other_area.max.y))
		},
	};
	
	
	let bank = props.art.bank_index;
	let other_bank = other_props.art.bank_index;
	let other_data = collision_data[other_bank];
	
	for (let x = common_area.min.x; x < common_area.max.x; x++) {
		for (let y = common_area.min.y; y < common_area.max.y; y++) {
			// TODO: Deduplicate
			let pixel_x = x - Math.floor(props.position.x) + half_size;
			let pixel_y = y - Math.floor(props.position.y) + half_size;
			let other_pixel_x = x - Math.floor(other_props.position.x) + other_half_size;
			let other_pixel_y = y - Math.floor(other_props.position.y) + other_half_size;
			if (pixel_x < 0 || pixel_x >= size ||
				other_pixel_x < 0 || other_pixel_x >= other_size ||
				pixel_y < 0 || pixel_y >= size ||
				other_pixel_y < 0 || other_pixel_y >= other_size) {
				continue;
			}
			if (bank in collision_data && other_bank in collision_data) {
				let index = Math.floor(pixel_y * size + pixel_x);
				let data = collision_data[bank];
				let alpha = data[index * COLOUR_BYTES_COUNT + 3];
				//console.assert(alpha !== undefined);
				let pixel = alpha != 0;
				let other_index = Math.floor(other_pixel_y * other_size + other_pixel_x);
				let other_data = collision_data[other_bank];
				let other_alpha = other_data[other_index * COLOUR_BYTES_COUNT + 3];
				let other_pixel = other_alpha != 0;
				//console.assert(other_alpha !== undefined);
				if (pixel && other_pixel) {
					return true;
				}
			}
		}
	}
	
	return false;
}

function attempt_to_jump(properties, index, area, collision_data, max_jump_attempts) {
	let props = properties[index];
	attempts_loop: for (let attempts = 0; attempts < max_jump_attempts; attempts++) {
		props.position = position_in_area(area, props.size);
		object_loop: for (let other_index = 0; other_index < OBJECT_COUNT; other_index++) {
			if (index === other_index) {
				continue object_loop;
			}
			if (properties[other_index] === null || properties[other_index].position === null) {
				continue object_loop;
			}
			if (are_touching(properties, index, other_index, collision_data)) {
				continue attempts_loop;
			}
		}
		break;
	}
}

function is_triggered(state, i, trigger, game_data) {
	let has_made_contact = (props, collided) => {
		let filter_touches = (props) => {
			return props.touched_previous_frame.filter(t => t != trigger);
		};
		if (trigger.contact === ContactType.Overlap) {
			return collided;
		} else {
			if (!collided) {
				props.touched_previous_frame = filter_touches(props);
				return false;
			}
			if (props.touched_previous_frame.includes(trigger)) {
				return false;
			} else {
				props.touched_previous_frame.push(trigger);
				return true;
			}
		}
	}
	
	let time_with_end = (time) => {
		if (time === Time.End) {
			if (game_data.length === Length.Short || game_data.length === Length.Boss) {
				return 32;
			} else if (game_data.length === Length.Long) {
				return 64;
			}
		} else {
			return time;
		}
	};

	let props = state.properties[i];
	switch (trigger.tag) {
		case Trigger.TapAnywhere: {
			return mouse.state === ButtonState.Press;
		}
		case Trigger.TapThisObject: {
			let size = props.size;
			/*let half_size = size / 2;
			if (mouse.state === ButtonState.Press) {
				let pixel_x = Math.floor(mouse.x - props.position.x + half_size);
				let pixel_y = Math.floor(mouse.y - props.position.y + half_size);
				if (pixel_x < 0.0
					|| pixel_x >= size
					|| pixel_y < 0.0
					|| pixel_y >= size)
				{
					return false;
				} else {
					let bank = props.art.bank_index;
					if (bank in game_data.collision_data) {
						let index = Math.floor(pixel_y * size + pixel_x);
						let data = game_data.collision_data[bank];
						let alpha = data[index * COLOUR_BYTES_COUNT + 3];
						console.assert(alpha !== undefined);
						return alpha != 0;
					}
				}
			}
			return false;*/
			if (mouse.state === ButtonState.Press) {
				let pixel_x = Math.floor(mouse.x);
				let pixel_y = Math.floor(mouse.y);
				let index = Math.floor(pixel_y * BACKGROUND_WIDTH + pixel_x);
				let object_pixel_is_on_top = collision_pixels[index * COLOUR_BYTES_COUNT] === i;
				let pixel_has_colour = collision_pixels[index * COLOUR_BYTES_COUNT + 3] === 255;
				let is_tapped = object_pixel_is_on_top && pixel_has_colour;
				return is_tapped;
			} else {
				return false;
			}
		}
		case Trigger.TimeExact: {
			let when = time_with_end(trigger.when);
			
			if (when % 2 === 0) {
				when = (when / 2) * 15;
			} else {
				when = Math.floor(when / 2) * 15 + 8;
			}
			return when === state.frame;
		}
		case Trigger.TimeRandom: {
			let is_quarter = (state.frame % 8 === 0 && state.frame % 16 !== 0) || state.frame % 15 === 0;
			if (props.done_time_triggers.includes(trigger)) {
				return false;
			} else if (is_quarter) {
				let start = trigger.start;
				let end = time_with_end(trigger.end);
				let quarter = state.frame % 15 === 0 ? Math.floor(state.frame / 15) * 2 : Math.floor(state.frame / 8);
				let r = random_int_in_range(Math.max(start, quarter), end + 1);
				let triggered = r === quarter;
				if (triggered) {
					props.done_time_triggers.push(trigger);
				}
				
				return triggered;
			} else {
				return false;
			}
		}
		case Trigger.Contact: {
			if (trigger.touches.what === TouchesWhat.Location) {			
				let size = props.size;
				let half_size = size / 2;
				let area = trigger.touches.area;
				let collided = false;
				let position_x = Math.floor(props.position.x);
				let position_y = Math.floor(props.position.y);
				if (position_x - half_size < area.max.x
					&& position_x + half_size > area.min.x
					&& position_y - half_size < area.max.y
					&& position_y + half_size > area.min.y)
				{
					location_loop: for (let x = area.min.x; x <= area.max.x; x++) {
						for (let y = area.min.y; y <= area.max.y; y++) {
							let pixel_x = Math.floor(x - position_x + half_size);
							let pixel_y = Math.floor(y - position_y + half_size);

							if (pixel_x < 0 || pixel_x >= size || pixel_y < 0 || pixel_y >= size) {
								continue;
							}
							let bank = props.art.bank_index;
							if (bank in game_data.collision_data) {
								let index = Math.floor(pixel_y * size + pixel_x);
								let data = game_data.collision_data[bank];
								let alpha = data[index * COLOUR_BYTES_COUNT + 3];
								if (alpha !== 0 && alpha !== undefined) {
									collided = true;
									break location_loop;
								}
							}
						}
					}
				}
				return has_made_contact(props, collided);
			} else {
				let collided = are_touching(state.properties, i, trigger.touches.index, game_data.collision_data);
				let contact = has_made_contact(props, collided);
				return contact;
			}
		}
		case Trigger.Switch: {
			let when = trigger.switch_when;
			let switch_state = state.properties[trigger.index].switch_state;
			if (when === SwitchWhen.IsOn
				&& (switch_state === SwitchWhen.IsOn
					|| switch_state === SwitchWhen.TurnsOn))
			{
				return true;
			} else if (when === SwitchWhen.IsOff
				&& (switch_state === SwitchWhen.IsOff
					|| switch_state === SwitchWhen.TurnsOff))
			{
				return true;
			} else if (when === SwitchWhen.TurnsOn
				&& switch_state === SwitchWhen.TurnsOn)
			{
				return true;
			} else if (when === SwitchWhen.TurnsOff
				&& switch_state === SwitchWhen.TurnsOff)
			{
				return true;
			} else {
				return false;
			}
		}
		case Trigger.FinishesPlaying: {
			return props.art.finished_playing;
		}
		case Trigger.SpecificArt: {
			return props.art.art_index === trigger.index;
		}
		case Trigger.GameCondition: {
			let condition = trigger.condition;
			let win_status = state.win_status;
			if (condition == GameCondition.Win
				&& win_status == GameCondition.Win)
			{
				return true;
			} else if (condition == GameCondition.Loss
				&& win_status == GameCondition.Loss)
			{
				return true;
			} else if (condition == GameCondition.HasBeenWon
				&& (win_status == GameCondition.Win
					|| win_status == GameCondition.HasBeenWon))
			{
				return true;
			} else if (condition == GameCondition.HasBeenLost
				&& (win_status == GameCondition.Loss
					|| win_status == GameCondition.HasBeenLost))
			{
				return true;
			} else if (condition == GameCondition.NotYetLost
				&& (win_status != GameCondition.Loss
					&& win_status != GameCondition.HasBeenLost))
			{
				return true;
			} else if (condition == GameCondition.NotYetWon
				&& (win_status != GameCondition.Win
					&& win_status != GameCondition.HasBeenWon))
			{
				return true;
			} else {
				return false;
			}
		}
		default: {
			console.warn('Unreachable Trigger');
		}
	}
}

let possible_directions = [
	SpecificDirection.North,
	SpecificDirection.NorthEast,
	SpecificDirection.East,
	SpecificDirection.SouthEast,
	SpecificDirection.South,
	SpecificDirection.SouthWest,
	SpecificDirection.West,
	SpecificDirection.NorthWest
];

let velocity_from_direction = (direction, speed) => {
	let diagonal_speed = speed / Math.sqrt(2);
	switch (direction) {
		case SpecificDirection.North: {
			return { x: 0, y: -speed };
		}
		case SpecificDirection.NorthEast: {
			return { x: diagonal_speed, y: -diagonal_speed };
		}
		case SpecificDirection.East: {
			return { x: speed, y: 0 };
		}
		case SpecificDirection.SouthEast: {
			return { x: diagonal_speed, y: diagonal_speed };
		}
		case SpecificDirection.South: {
			return { x: 0, y: speed };
		}
		case SpecificDirection.SouthWest: {
			return { x: -diagonal_speed, y: diagonal_speed };
		}
		case SpecificDirection.West: {
			return { x: -speed, y: 0 };
		}
		case SpecificDirection.NorthWest: {
			return { x: -diagonal_speed, y: -diagonal_speed };
		}
	}
};

function clone_position(position) {
	return { x: position.x, y: position.y };
}

function clone_area(area) {
	return { min: clone_position(area.min), max: clone_position(area.max)};
}

function apply_action(state, i, action, game_data) {
	let props = state.properties[i];
	switch (action.tag) {
		case Action.Travel: {
			switch (action.travel) {
				case Travel.GoStraight: {
					if (action.from.tag === FromLocation.AnotherPosition) {
						props.position = clone_position(action.from.position);
					} else if (action.from.tag === FromLocation.AnotherObject) {
						// TODO: Is this done from the position at the start of the frame?
						props.position = clone_position(state.properties[action.from.index].position);
						props.position.x += action.from.offset.x;
						props.position.y += action.from.offset.y;
					}
					let speed = value_from_speed(action.speed);
					let travel;
					if (action.direction.tag === Direction.Random) {
						let direction = random_in_array(possible_directions);
						let velocity = velocity_from_direction(direction, speed);
						travel = { tag: ActiveTravel.GoStraight, velocity };
					} else if (action.direction.tag === Direction.Specific) {
						let direction = action.direction.direction;
						let velocity = velocity_from_direction(direction, speed);
						travel = { tag: ActiveTravel.GoStraight, velocity };
					} else {
						let position = action.direction.position;
						travel = { tag: ActiveTravel.GoToPoint, position, speed };
					}
					props.travel.push(travel);
					return;
				}
				case Travel.Stop: {
					props.travel.push({ tag: ActiveTravel.Stop });
					return;
				}
				case Travel.JumpToPosition: {
					//props.position = clone_position(action.position);
					props.travel.push({ tag: ActiveTravel.JumpToPosition, position: clone_position(action.position) });
					props.travel.push({ tag: ActiveTravel.Stop });
					return;
				}
				case Travel.JumpToArea: {
					/*if (action.overlap === Overlap.Anywhere) {
						props.position = position_in_area(action.area, props.size);
					} else {
						attempt_to_jump(state.properties, i, action.area, game_data.collision_data, MAX_DURING_GAME_JUMP_ATTEMPTS);
					}
					props.travel.push({ tag: ActiveTravel.Stop });*/
					
					
					let area = clone_area(action.area);
					let art_index = props.art.art_index;
					let collision_area = game_data.objects[i].art[art_index].collision_area;
					area.min.x -= collision_area.min.x;
					area.min.y -= collision_area.min.y;
					area.max.x += props.size - collision_area.max.x;
					area.max.y += props.size - collision_area.max.y;
					props.travel.push({ tag: ActiveTravel.JumpToArea, area, overlap: action.overlap });
					props.travel.push({ tag: ActiveTravel.Stop });
					return;
				}
				case Travel.JumpToObject: {
					/*props.position = clone_position(state.properties[action.index].position);
					props.position.x += action.offset.x;
					props.position.y += action.offset.y;*/
					props.travel.push({ tag: ActiveTravel.AttachTo, index: action.index, offset: action.offset });
					return;
				}
				case Travel.Roam: {
					let speed = value_from_speed(action.speed);
					let direction = random_in_array(possible_directions);
					let velocity = velocity_from_direction(direction, speed);
					let area = clone_area(action.area);
					let half_size = props.size / 2;
					area.min.x += half_size;
					area.min.y += half_size;
					area.max.x -= half_size;
					area.max.y -= half_size;
					
					let art_index = props.art.art_index;
					let collision_area = game_data.objects[i].art[art_index].collision_area;
					area.min.x -= collision_area.min.x;
					area.min.y -= collision_area.min.y;
					area.max.x += props.size - collision_area.max.x;
					area.max.y += props.size - collision_area.max.y;
					let overlap = action.overlap;
					let travel;
					let roam = action.roam;
					let tag = ActiveTravel.Roam;
					let last_travel = props.travel[props.travel.length - 1];
					if (roam === Roam.Wiggle) {
						travel = { tag, roam, area, speed, overlap };
					} else if (roam === Roam.Insect) {
						if (last_travel.roam === Roam.Insect) {
							velocity = last_travel.velocity;
						}
						travel = { tag, roam, area, speed, overlap, velocity };
					} else if (roam === Roam.Reflect) {
						if (area.min.x < area.max.x && area.min.y < area.max.y) {
							let angle = random_in_range(0, Math.PI * 2);
							velocity = { x: speed * Math.cos(angle), y: speed * Math.sin(angle) };
						} else if (area.min.x > area.max.x) {
							velocity = { x: 0, y: speed };
						} else {
							velocity = { x: speed, y: 0 };
						}
						/*if (last_travel.tag === ActiveTravel.GoStraight) {
							// TODO: Adjust for speed
							velocity = clone_position(last_travel.velocity);
							let d = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));
							velocity.x = velocity.x / d * speed;
							velocity.y = velocity.y / d * speed;
						}*/
						travel = { tag, roam, area, speed, overlap, velocity, has_moved_freely: true };
					} else if (roam === Roam.Bounce) {
						// TODO: Temporary code until figure out equation for bounce speed for different area sizes
						// TODO: Use collision size not sprite size
						let area_height = area.max.y - area.min.y;
						let art_index = props.art.art_index;
						let collision_area = game_data.objects[i].art[art_index].collision_area;
						let object_height = collision_area.max.y - collision_area.min.y;
						

						let acceleration = speed / 16;
						
						let velocity = {
							x: 0,
							y: props.position.y > area.min.y ? -Math.sqrt(2 * acceleration * (props.position.y - area.min.y)) : 0.0
						};
						let direction = random_in_array([BounceDirection.Left, BounceDirection.Right]);
						let horizontal_speed = speed / 2;
						if (direction === BounceDirection.Left) {
							velocity.x = horizontal_speed;
						} else {
							velocity.x -= horizontal_speed;
						}

						if (last_travel.tag === ActiveTravel.GoStraight) {
							// TODO: Add velocity to GoToPoint to use here? or just calc now. and check if gotopoint is called same frame as bounce in game this affects before thought
							velocity = clone_position(last_travel.velocity);
							
							direction = BounceDirection.None;
						} else if (last_travel.tag === ActiveTravel.GoToPoint) {
							// TODO: Why still need bounce direction?
							let position = last_travel.position;
							let target_vector = { x: position.x - props.position.x, y: position.y - props.position.y };
							let d = Math.sqrt(Math.pow(target_vector.x, 2) + Math.pow(target_vector.y, 2));
							velocity = {
								x: target_vector.x / d * speed / 2,
								y: target_vector.y / d * speed
							};
							if (props.position.x < last_travel.position.x) {
								direction = BounceDirection.Right;
							} else if (props.position.x > last_travel.position.x) {
								direction = BounceDirection.Left;
							} else {
								direction = BounceDirection.None;
							}
							//velocity
						} else if (last_travel.tag === ActiveTravel.Roam && last_travel.roam === Roam.Bounce) {
							velocity = clone_position(last_travel.velocity);
							direction = last_travel.direction;
						} else if (last_travel.tag === ActiveTravel.GoToObject) {
							let position = state.properties[last_travel.index].position;
							let target_vector = { x: position.x - props.position.x, y: position.y - props.position.y };
							let d = Math.sqrt(Math.pow(target_vector.x, 2) + Math.pow(target_vector.y, 2));
							velocity = {
								x: target_vector.x / d * speed,
								y: target_vector.y / d * speed
							};
						}
						travel = { tag, roam, area, speed, overlap, velocity, acceleration, direction };
					}
					props.travel.push(travel);
					return;
				}
				case Travel.Swap: {
					/*let temp = clone_position(props.position);
					props.position = clone_position(state.properties[action.index].position);
					state.properties[action.index].position = temp;*/
					props.travel.push({ tag: ActiveTravel.Swap, index: action.index });
					props.travel.push({ tag: ActiveTravel.Stop });
					state.properties[action.index].travel.push({ tag: ActiveTravel.Stop });
					return;
				}
				case Travel.Target: {
					let index = action.index;
					let offset = action.offset;
					let speed = value_from_speed(action.speed);
					props.travel.push({ tag: ActiveTravel.GoToObject, index, offset, speed });
					return;
				}
				default: {
					console.warn('Unreachable Travel', action.travel);
					return;
				}
			}
		}
		case Action.Switch: {
			let new_switch;
			if (action.switch_to === Switch.Off) {
				new_switch = SwitchWhen.TurnsOff;
			} else {
				new_switch = SwitchWhen.TurnsOn;
			}
			props.next_switch_state = new_switch;
			return;
		}
		case Action.Lose: {
			console.log('Lose Action Applied. win_status before: {:?}', state.win_status);
			if (state.win_status != GameCondition.Win
				&& state.win_status != GameCondition.Loss
				&& state.win_status != GameCondition.HasBeenLost
				&& state.win_status != GameCondition.HasBeenWon)
			{
				random_in_array(lose_sounds).play();
				state.win_status = GameCondition.Loss;
			}
			return;
		}
		case Action.StopPlaying: {
			props.art.style = AnimationStyle.Hold;
			return;
		}
		case Action.ChangeArt: {
			props.art.art_index = action.index;
			let art = game_data.objects[i].art[action.index];
			let bank = art.bank[0];
			props.art.bank_index = bank;
			props.art.animation_index = 0;
			props.art.finished_playing = false;
			props.art.time_to_next_change = animation_time_from_speed(action.speed);
			props.art.speed = action.speed;
			props.art.style = action.style;
			return;
		}
		case Action.SoundEffect: {
			if (sounds[action.effect].paused) {
				sounds[action.effect].play();
			}
			return;
		}
		case Action.ScreenEffect: {
			// TODO: Implement others
			if (action.effect === ScreenEffect.Freeze) {
				state.is_frozen = true;
			}
			return;
		}
	}
}

function run_frame(game_data, state, assets) {
	if (game_data.id !== game_id) {
		return;
	}
	
	let frame_delay = 1000 / 60;
	if (state.time > state.frame * frame_delay) {
		update_game(game_data, state, assets);
	}

	requestAnimationFrame(time => {
		if (state.last_timestamp === null) {
			state.last_timestamp = time;
		}
		
		state.time += (time - state.last_timestamp);
		state.last_timestamp = time;
		run_frame(game_data, state, assets);
	})
}

function update_game(game_data, state, assets) {
	let old_win_status = state.win_status;
	let triggered_actions = [];
	
	if (mouse.state === ButtonState.Up || mouse.state === ButtonState.Release) { 
		if (mouse_down) {
			console.log('Mouse pressed');
			mouse.state = ButtonState.Press;
		} else {
			mouse.state = ButtonState.Up;
		}
	} else if (mouse.state === ButtonState.Down || mouse.state === ButtonState.Press) { 
		if (mouse_down) {
			mouse.state = ButtonState.Down;
		} else {
			mouse.state = ButtonState.Release;
		}
	}
	
	if (!state.is_frozen) {
		for (let i = 0; i < game_data.objects.length; i++) {
			triggered_actions.push([]);
			if (game_data.objects[i] === null) continue;
			let object = game_data.objects[i];
			for (let ins = 0; ins < object.instructions.length; ins++) {
				// To avoid short-circuiting as game logic requires collision checking for touches trigger
				let triggered = object.instructions[ins].triggers.map(trigger => is_triggered(state, i, trigger, game_data)).every(result => result === true);
				if (triggered) {
					let actions = object.instructions[ins].actions;
					triggered_actions[i] = triggered_actions[i].concat(actions);
				}
			}
		}
		
		for (let i = 0; i < triggered_actions.length; i++) {
			triggered_actions[i].forEach(action => apply_action(state, i, action, game_data));
		}
		
		for (let i = 0; i < game_data.objects.length; i++) {
			if (game_data.objects[i] === null) continue;
			let object = game_data.objects[i];
			let props = state.properties[i];
			
			let art = object.art[props.art.art_index]
			let animation_index = props.art.animation_index;
			animation_index++;
			animation_index %= art.bank.length;
			
			let bank = art.bank[animation_index];
			
			props.art.finished_playing = false;
			
			let go_to_next_image = props => {
				props.art.animation_index = animation_index;
				props.art.bank_index = bank;
				props.art.time_to_next_change = animation_time_from_speed(props.art.speed);
			};
			
			if (props.art.style !== AnimationStyle.Hold && props.art.time_to_next_change === 0) {
				if (animation_index === 0) {
					if (props.art.style === AnimationStyle.Loop) {
						go_to_next_image(props);
					} else if (props.art.style === AnimationStyle.PlayOnce) {
						props.art.style = AnimationStyle.Hold;
						props.art.finished_playing = true;
					}
				} else {
					go_to_next_image(props);
				}
			}
			
			if (props.art.style !== AnimationStyle.Hold) {
				props.art.time_to_next_change--;
			}
		}
		
		for (let i = 0; i < game_data.objects.length; i++) {
			if (game_data.objects[i] === null) continue;
			let props = state.properties[i];
			let last_move = 0;
			for (let t = 0; t < props.travel.length; t++) {
				let travel = props.travel[t];
				// TODO: Rethink this
				if (travel.tag === ActiveTravel.GoStraight
						|| travel.tag === ActiveTravel.GoStraight
						|| travel.tag === ActiveTravel.GoToPoint
						|| travel.tag === ActiveTravel.GoToObject
						|| travel.tag === ActiveTravel.Roam
						|| travel.tag === ActiveTravel.Stop) {
					last_move = t;
				}
			}
			for (let t = 0; t < props.travel.length; t++) {
				let travel = props.travel[t];
				
				let move_coordinate_to = (x, other, velocity) => {
					if (Math.abs(x - other) > Math.abs(velocity)) {
						return x + velocity;
					} else {
						return other;
					}
				};
				let go_to = (props, position) => {
					let target_vector = { x: position.x - props.position.x, y: position.y - props.position.y };
					let d = Math.sqrt(Math.pow(target_vector.x, 2) + Math.pow(target_vector.y, 2));
					let velocity = {
						x: target_vector.x / d * travel.speed,
						y: target_vector.y / d * travel.speed
					};
					props.position = {
						x: move_coordinate_to(props.position.x, position.x, velocity.x),
						y: move_coordinate_to(props.position.y, position.y, velocity.y)
					};
					return velocity;
				};
				
				switch (travel.tag) {
					case ActiveTravel.JumpToPosition: {
						props.position = clone_position(travel.position);
						break;
					}
					case ActiveTravel.JumpToArea: {
						if (travel.overlap === Overlap.Anywhere) {
							props.position = position_in_area(travel.area, props.size);
						} else {
							attempt_to_jump(state.properties, i, travel.area, game_data.collision_data, MAX_DURING_GAME_JUMP_ATTEMPTS);
						}
						break;
					}
					case ActiveTravel.Swap: {
						let temp = clone_position(props.position);
						props.position = clone_position(state.properties[travel.index].position);
						state.properties[travel.index].position = temp;
						break;
					}
					case ActiveTravel.GoStraight: {
						if (t < last_move) {
							continue;
						}
						props.position.x += travel.velocity.x;
						props.position.y += travel.velocity.y;
						break;
					}
					case ActiveTravel.GoToPoint: {
						if (t < last_move) {
							continue;
						}
						let position = clone_position(travel.position);
						go_to(props, position);
						break;
					}
					case ActiveTravel.GoToObject: {
						if (t < last_move) {
							continue;
						}
						let position = clone_position(state.properties[travel.index].position);
						position.x += travel.offset.x;
						position.y += travel.offset.y;
						go_to(props, position);
						break;
					}
					case ActiveTravel.AttachTo: {
						let position = clone_position(state.properties[travel.index].position);
						position.x += travel.offset.x;
						position.y += travel.offset.y;
						props.position = position;
						break;
					}
					case ActiveTravel.Roam: {
						if (t < last_move) {
							continue;
						}
						let area = travel.area;
						let centre = { x: (area.min.x + area.max.x) / 2, y: (area.min.y + area.max.y) / 2 };
						let is_position_in_area = (position, area) => {
							return position.x >= area.min.x && position.x <= area.max.x
								&& position.y >= area.min.y && position.y <= area.max.y;
						};
						if (travel.roam === Roam.Wiggle) {
							if (is_position_in_area(props.position, area)) {
								let directions = possible_directions;
								if (travel.overlap === Overlap.TryNotToOverlap) {
									let position = clone_position(props.position);
									let non_overlapping_directions = [];
									direction_loop: for (d = 0; d < possible_directions.length; d++) {
										props.position = clone_position(position);
										let direction = possible_directions[d];
										let velocity = velocity_from_direction(direction, travel.speed);
										props.position.x += velocity.x;
										props.position.y += velocity.y;
										object_loop: for (let other_index = 0; other_index < OBJECT_COUNT; other_index++) {
											if (i === other_index) {
												continue object_loop;
											}
											if (properties[other_index] === null || properties[other_index].position === null) {
												continue object_loop;
											}
											if (are_touching(properties, i, other_index, collision_data)) {
												continue direction_loop;
											}
										}
										
										non_overlapping_directions.push(direction);
									}
									if (non_overlapping_direction.length === 0) {
										directions = possible_directions;
									} else {
										directions = non_overlapping_directions;
									}
									
									props.position = clone_position(position);
								}
								let direction = random_in_array(possible_directions);
								let velocity = velocity_from_direction(direction, travel.speed);
								
								props.position.x += velocity.x;
								props.position.y += velocity.y;
							} else {
								go_to(props, centre);
							}
							
						} else if (travel.roam === Roam.Insect) {
							if (is_position_in_area(props.position, area)) {
								const CHANGE_DIRECTION_PROBABILTY = 0.05;
								if (random_in_range(0, 1) < CHANGE_DIRECTION_PROBABILTY) {
									let direction = random_in_array(possible_directions);
									travel.velocity = velocity_from_direction(direction, travel.speed);
								}
								props.position.x += travel.velocity.x;
								props.position.y += travel.velocity.y;
							} else {
								let direction = random_in_array(possible_directions);
								travel.velocity = velocity_from_direction(direction, travel.speed);
								go_to(props, centre);
							}
						} else if (travel.roam === Roam.Reflect) {
							if (travel.overlap === Overlap.TryNotToOverlap) {
								let touching = false;
								let touching_index;
								object_loop: for (let other_index = 0; other_index < OBJECT_COUNT; other_index++) {
									if (i === other_index) {
										continue object_loop;
									}
									if (state.properties[other_index] === null || state.properties[other_index].position === null) {
										continue object_loop;
									}
									if (are_touching(state.properties, i, other_index, game_data.collision_data)) {
										touching_index = other_index;
										touching = true;
									}
								}
								if (touching) {
									if (props.position.x < state.properties[touching_index].position.x) {
										travel.velocity.x = -Math.abs(travel.velocity.x);
									}
									if (props.position.x > state.properties[touching_index].position.x) {
										travel.velocity.x = Math.abs(travel.velocity.x);
									}
									if (props.position.y < state.properties[touching_index].position.y) {
										travel.velocity.y = -Math.abs(travel.velocity.y);
									}
									if (props.position.y > state.properties[touching_index].position.y) {
										travel.velocity.y = Math.abs(travel.velocity.y);
									}
								}
							}
							if (props.position.x + travel.velocity.x < area.min.x) {
								travel.velocity.x = Math.abs(travel.velocity.x);
							}
							if (props.position.x + travel.velocity.x > area.max.x) {
								travel.velocity.x = -Math.abs(travel.velocity.x);
							}
							if (props.position.y + travel.velocity.y < area.min.y) {
								travel.velocity.y = Math.abs(travel.velocity.y);
							}
							if (props.position.y + travel.velocity.y > area.max.y) {
								travel.velocity.y = -Math.abs(travel.velocity.y);
							}
							// When area is smaller than object
							if (props.position.x >= area.max.x && props.position.x <= area.min.x) {
								travel.velocity.x = 0;
							}
							if (props.position.y >= area.max.y && props.position.y <= area.min.y) {
								travel.velocity.y = 0;
							}
							props.position.x += travel.velocity.x;
							props.position.y += travel.velocity.y;
						} else if (travel.roam === Roam.Bounce) {
							// TODO: Implement TryNotToOverlap for bounce
							if (props.position.y < area.min.y) {
								// TODO: Why is abs necessary?
								travel.velocity.y += Math.abs(travel.acceleration);
							} else if (props.position.y < area.max.y) {
								travel.velocity.y += travel.acceleration;
							} else if (props.position.y > area.max.y) {
								travel.velocity.y = props.position.y > travel.area.min.y ? -Math.sqrt(2 * travel.acceleration * (props.position.y - travel.area.min.y)) : 0.0;
							}
							if (props.position.x > area.max.x) {
								travel.velocity.x = -Math.abs(travel.velocity.x);
							} else if (props.position.x < area.min.x) {
								travel.velocity.x = Math.abs(travel.velocity.x);
							}
							let horizontal_speed = travel.speed / 2;
							if (area.min.x >= area.max.x) {
								let centre_x = (area.min.x + area.max.x) / 2.0
								if (props.position.x > centre_x) {
									horizontal_speed = -horizontal_speed;
								}
								props.position.x = move_coordinate_to(props.position.x, centre_x, horizontal_speed);
							} else {
								props.position.x += travel.velocity.x;
							}
							props.position.y += travel.velocity.y;
						}
						break;
					}
				}
			}
			
			props.travel = [props.travel[props.travel.length - 1]];
			
		}
		
		for (let i = 0; i < game_data.objects.length; i++) {
			if (game_data.objects[i] === null) continue;
			let props = state.properties[i];
			if (props.switch_state === SwitchWhen.TurnsOff) {
				props.switch_state = SwitchWhen.IsOff;
			} else if (props.switch_state === SwitchWhen.TurnsOn) {
				props.switch_state = SwitchWhen.IsOn;
			}
			if (props.next_switch_state === SwitchWhen.TurnsOn && props.switch_state === SwitchWhen.IsOff) {
				props.switch_state = SwitchWhen.TurnsOn;
			}
			if (props.next_switch_state === SwitchWhen.TurnsOff && props.switch_state === SwitchWhen.IsOn) {
				props.switch_state = SwitchWhen.TurnsOff;
			}
		}
		
		if (GameCondition.Win == old_win_status) {
			state.win_status = GameCondition.HasBeenWon;
		} else if (GameCondition.Loss == old_win_status) {
			state.win_status = GameCondition.HasBeenLost;
		}
		
		if (state.win_status == GameCondition.NotYetWon) {
			for (let condition_index = 0; condition_index < game_data.win_conditions.length; condition_index++) {
				let conditions = game_data.win_conditions[condition_index];
				let won = null;
				for (let which = 0; which < conditions.length; which++) {
					let win_condition = conditions[which];
					let switch_when = win_condition.switch_state;
					let props = state.properties[win_condition.index];
					let same;
					if (switch_when == Switch.On
						&& (props.switch_state == SwitchWhen.IsOn
							|| props.switch_state == SwitchWhen.TurnsOn))
					{
						same = true;
					} else if (switch_when == Switch.Off
						&& (props.switch_state == SwitchWhen.IsOff
							|| props.switch_state == SwitchWhen.TurnsOff))
					{
						same = true;
					} else {
						same = false;
					};
					if (won !== null) {
						won = won && same;
					} else {
						won = same;
					}
				}
				
				if (won === true) {
					console.log('Game Won');
					random_in_array(win_sounds).play();
					state.win_status = GameCondition.Win;
				}
			}
		}
		
		let end;
		if (game_data.length === Length.Short) {
			end = 32;
		} else if (game_data.length === Length.Long) {
			end = 64;
		}
		if (game_data.length !== Length.Boss) {
			if (state.frame === end * 8) {
				if (state.win_status != GameCondition.Win
					&& state.win_status != GameCondition.Loss
					&& state.win_status != GameCondition.HasBeenLost
					&& state.win_status != GameCondition.HasBeenWon)
				{
					random_in_array(lose_sounds).play();
					state.win_status = GameCondition.Loss;
					console.log('Ran out of time');
				}
			}
		}
	}
	
	if (state.is_frozen) {
		context.filter = 'invert(1)';
	} else {
		context.filter = 'none';
	}
	context.drawImage(assets.background_image, 0, 0);
	collision_context.clearRect(0, 0, collision_canvas.width, collision_canvas.height);
	
	let layer_count = Math.min(game_data.layers.length, state.properties.length);
	
	for (let layer = 0; layer < layer_count; layer++) {
		let i = game_data.layers[layer];
		let props = state.properties[i];
		if (props !== null) {
			let size = props.size;
			let half_size = size / 2;
			let bank = props.art.bank_index;
			let image = assets.image_data[bank];
			let position = props.position;
			context.drawImage(image, Math.floor(position.x - half_size), Math.floor(position.y - half_size));
			let collision_image = game_data.collision_data[bank].sprite;
			collision_context.drawImage(collision_image, Math.floor(position.x - half_size), Math.floor(position.y - half_size));
		}
	}
	
	collision_pixels = collision_context.getImageData(0, 0, BACKGROUND_WIDTH, BACKGROUND_HEIGHT).data;
	
	state.frame++;
}

function drag_over_handler(event) {
	console.log('Drag');
	event.preventDefault();
}
</script>


</body>
</html>
