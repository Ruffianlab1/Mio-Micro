<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>Gamedev Canvas Workshop</title>
	<script type='text/javascript' src='import.js'></script>
    <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: #fff; display: block; margin: 0 auto; }
    </style>
</head>
<body style='overflow:hidden'>

<canvas id='canvas' width='192' height='128' ondrop='dropHandler(event);' ondragover='dragOverHandler(event);'></canvas>

<script>

const BACKGROUND_WIDTH = 192;
const BACKGROUND_HEIGHT = 128;
const BACKGROUND_PIXEL_COUNT = BACKGROUND_WIDTH * BACKGROUND_HEIGHT;
const COLOUR_BYTES_COUNT = 4;

let canvas = document.getElementById('canvas');
let context = canvas.getContext('2d');

let intro = new Image();
intro.src = 'images/intro.png';

intro.onload = () => {
    context.drawImage(intro, 0, 0);   
}

let random_in_range = (min, max) => min + Math.floor((max - min) * Math.random());
let random_int_in_range = (min, max) => Math.floor(random_in_range(min, max));
let random_in_array = (array) => array[random_int_in_range(0, array.length)];

function position_in_area(area, size) {
	let half_size = size / 2;
    let min_x = area.min.x + half_size;
    let max_x = area.max.x - half_size;
    let x;
	if (min_x > max_x) {
        x = (area.min.x + area.max.x) / 2;
    } else {
        x = random_int_in_range(min_x, max_x);
    };
    let min_y = area.min.y + half_size;
    let max_y = area.max.y - half_size;
    let y;
	if (min_y > max_y) {
        y = (area.min.y + area.max.y) / 2;
    } else {
        y = random_int_in_range(min_y, max_y);
    }
    return { x, y }
}

function animation_time_from_speed(speed) {
	let time;
	switch (speed) {
		case Speed.Slowest: {
			time = 16;
			break;
		}
		case Speed.Slow: {
			time = 8;
			break;
		}
		case Speed.Normal: {
			time = 4;
			break;
		}
		case Speed.Fast: {
			time = 2;
			break;
		}
		case Speed.Fastest: {
			time = 1;
			break;
		}
	}
	return 8 * time;
};

function value_from_speed(speed) {
	let value;
	switch (speed) {
		case Speed.Slowest: {
			value = 1;
			break;
		}
		case Speed.Slow: {
			value = 2;
			break;
		}
		case Speed.Normal: {
			value = 4;
			break;
		}
		case Speed.Fast: {
			value = 8;
			break;
		}
		case Speed.Fastest: {
			value = 16;
			break;
		}
	}
	return 0.25 * value;
};

const ActiveTravel = {
	GoStraight: 'GoStraight',
	GoToPoint: 'GoToPoint',
	GoToObject: 'GoToObject',
	Roam: 'Roam',
	AttachTo: 'AttachTo',
	Stop: 'Stop'
};

let game_id = 0;

async function dropHandler(event) {
	game_id++;
	console.log('File(s) dropped');

	event.preventDefault();

	if (event.dataTransfer.items) {
		for (let item = 0; item < event.dataTransfer.items.length; item++) {
			if (event.dataTransfer.items[item].kind === 'file') {
				const file = event.dataTransfer.items[item].getAsFile();
				console.log('file: ', file.name);
				let buffer = await bufferFromFile(file);
				let data = new Uint8Array(buffer);
				let game_data = new GameData(data);
				console.log(game_data.name);
				
				let bg_offset = 0x100;
				let bg_length = 0x30FF - bg_offset;
				let scrambled_pixels = [];
				
				for (let i = bg_offset; i <= bg_offset + bg_length; i++) {
					scrambled_pixels.push(second_hex_digit(data[i]));
					scrambled_pixels.push(first_hex_digit(data[i]));
				}
				
				let pixel_value = pixel => {
					switch (pixel) {
						case 0x00: {
							return [0, 0, 0, 0];
						}
						case 0x01: {
							return [0, 0, 0, 255];
						}
						case 0x02: {
							return [255, 222, 156, 255];
						}
						case 0x03: {
							return [255, 173, 49, 255];
						}
						case 0x04: {
							return [198, 74, 0, 255];
						}
						case 0x05: {
							return [255, 0, 0, 255];
						}
						case 0x06: {
							return [206, 107, 239, 255];
						}
						case 0x07: {
							return [16, 198, 206, 255];
						}
						case 0x08: {
							return [41, 107, 198, 255];
						}
						case 0x09: {
							return [8, 148, 82, 255];
						}
						case 0x0A: {
							return [115, 214, 57, 255];
						}
						case 0x0B: {
							return [255, 255, 90, 255];
						}
						case 0x0C: {
							return [123, 123, 123, 255];
						}
						case 0x0D: {
							return [198, 198, 198, 255];
						}
						case 0x0E: {
							return [255, 255, 255, 255];
						}
						// TODO: Set 0x0F correctly
						case 0x0F: {
							return [0, 0, 255, 255];
						}
						default: {
							console.warn('Unreachable Pixel Colour', pixel);
						}
					}
				};
				
				let background_pixels = new Uint8ClampedArray(BACKGROUND_PIXEL_COUNT * COLOUR_BYTES_COUNT);
				
				for (let i = 0; i < BACKGROUND_PIXEL_COUNT; i++) {
					let block_size = 1536;
					let block_index = Math.floor(i / block_size);
					let internal_index = i % block_size;
					let grid_square_index = Math.floor(internal_index / 64);
					let grid_column_index = i % 8;
					let grid_row_index = Math.floor(internal_index / 8) % 8; // TODO:
					let column_index = (grid_square_index * 8 + grid_column_index);
					let row_index = (block_index * 8 + grid_row_index);
					
					let colour = pixel_value(scrambled_pixels[i]);
					
					for (let c = 0; c < colour.length; c++) {
						//let colour = [255, 0, 0, 255];
						let index = row_index * BACKGROUND_WIDTH + column_index;
						background_pixels[index * COLOUR_BYTES_COUNT + c] = colour[c];
					}
				}

				let background_image_data = context.createImageData(BACKGROUND_WIDTH, BACKGROUND_HEIGHT);
				background_image_data.data.set(background_pixels);
				
				let temp_canvas = document.createElement('canvas');
				let temp_context = temp_canvas.getContext('2d');

				temp_canvas.width = BACKGROUND_WIDTH;
				temp_canvas.height = BACKGROUND_HEIGHT;
				temp_context.putImageData(background_image_data, 0, 0);
				let background_image = new Image();
				background_image.src = temp_canvas.toDataURL();
	
				let images_offset = 0x3104;
				let images_length = 0xB103 - images_offset;
				let images_pixels = [];
				for (let i = images_offset; i <= images_offset + images_length; i++) {
					images_pixels.push(second_hex_digit(data[i]));
					images_pixels.push(first_hex_digit(data[i]));
				}
				
				let image_data = {};
				let collision_data = {};
				
				for (let i = 0; i < OBJECT_COUNT; i++) {
					let object = game_data.object(i);
					if (!object.is_active) {
						continue;
					}
					
					let size = object.sprite_size;
					
					for (let j = 0; j < ART_BANK_COUNT; j++) {
						let art = object.art(j);
						if (!art.is_active) {
							continue;
						}
						let bank = art.bank;
						for (let b = 0; b < bank.length; b++) {
							let grid_width = 8;
							let grid_height = 8;
							let grids_used;
							let grid_multiplier = 4;
							switch (size) {
								case 16: {
									grids_used = 1 * grid_multiplier;
									break;
								}
								case 32: {
									grids_used = 4 * grid_multiplier;
									break;
								}
								case 48: {
									grids_used = 9 * grid_multiplier;
									break;
								}
								case 64: {
									grids_used = 16 * grid_multiplier;
									break;
								}
								default: {
									console.warn('Unreachable Size');
								}
							}
							
							let first_grid = bank[b] * 4;
							let first_pixel_index = first_grid * grid_width * grid_height;
							let total_pixel_count = grids_used * grid_width * grid_height;
							
							let image = context.createImageData(size, size);
							for (let index = 0; index < total_pixel_count; index++) {
								let pixel = images_pixels[first_pixel_index + index];
								let grid = Math.floor(index / 64);
								let internal_grid_index = index % 64;
								let grid_column_index = index % 8;
								let grid_row_index = Math.floor(internal_grid_index / 8);
								let grid_base_x = grid % Math.floor(size / 8);
								let grid_base_y = Math.floor(grid / Math.floor(size / 8));
								let column_index = grid_base_x * 8 + grid_column_index;
								let row_index = grid_base_y * 8 + grid_row_index;
								
								let colour = pixel_value(pixel);
								
								for (let c = 0; c < colour.length; c++) {
									let pixel_index = row_index * size + column_index;
									image.data[pixel_index * COLOUR_BYTES_COUNT + c] = colour[c];
								}
							}
							let temp_canvas = document.createElement('canvas');
							let temp_context = temp_canvas.getContext('2d');

							temp_canvas.width = size;
							temp_canvas.height = size;
							temp_context.putImageData(image, 0, 0);
							let sprite = new Image();
							sprite.src = temp_canvas.toDataURL();
							image_data[bank[b]] = sprite;
							collision_data[bank[b]] = image.data;
						}
					}
				}
				
				let win_conditions = [];

				for (let i = 0; i < WIN_CONDITIONS_COUNT; i++) {
					win_conditions.push([]);
					for (let j = 0; j < SWITCH_CONDITIONS_COUNT; j++) {
						let condition = game_data.win_condition(i, j);
						if (condition !== null) {
							win_conditions[i].push(condition);
						}
					}
				}
				console.log(win_conditions);
				
				let length = game_data.length;
				
				let objects = [];
				
				for (let i = 0; i < OBJECT_COUNT; i++) {
					let object = game_data.object(i);
					
					if (object.is_active) {
						let art_set = [];
						for (let a = 0; a < OBJECT_ART_COUNT; a++) {
							let art = object.art(a);
							if (art.is_active) {
								let bank = art.bank;
								art_set.push({ name: art.name, bank });
							} else {
								art_set.push(null);
							}
						}
						
						let assembly = object.assembly;
						
						if (assembly.is_active) {
							let start_instruction = assembly.start_instruction;
						
							let instructions = [];
							
							for (let ins = 0; ins < INSTRUCTION_COUNT; ins++) {
								let instruction = assembly.instruction(ins);
								if (instruction.is_active) {
									let triggers = [];
									for (let t = 0; t < TRIGGER_COUNT; t++) {
										let trigger = instruction.trigger(t);
										if (trigger !== null) {
											triggers.push(trigger);
										}
									}
									let actions = [];
									for (let a = 0; a < ACTION_COUNT; a++) {
										let action = instruction.action(a);
										if (action !== null) {
											actions.push(action);
										}
									}
									instructions.push({ triggers, actions });
								}
							}
						
							objects.push({
								name: object.name,
								sprite_size: object.sprite_size,
								art: art_set,
								start_instruction,
								instructions,
							});
						}
					} else {
						objects.push(null);
					}
				}
				
				console.log(objects);
				
				console.log(JSON.stringify({ length, objects, win_conditions }, null, 4));
				
				let layers = [];
				
				for (let layer = 0; layer < objects.length; layer++) {
					// TODO: Verify this
					let index = data[0xE5F6 + objects.length - layer - 1];
					layers.push(index);
				}
				
				let properties = [];
				
				for (let i = 0; i < objects.length; i++) {
					if (objects[i] === null) {
						properties.push(null);
						continue;
					}
					let location = objects[i].start_instruction.location;
					let size = objects[i].sprite_size;
					let position;
					let travel = { tag: ActiveTravel.Stop };
					if (location.tag == StartLocation.Position) {
						position = clone_position(location.position);
					} else if (location.tag == StartLocation.Area) {
						// TODO: Does this use size only taking into account pixels with a colour value?
						position = position_in_area(location.area, size);
					} else if (location.tag == StartLocation.AttachToObject) {
						// TODO:
						position = { x: random_int_in_range(1000, 100000), y: random_int_in_range(1000, 100000) };
						
						travel = {
							tag: ActiveTravel.AttachTo,
							index: location.index,
							offset: location.offset
						};
					}
					
					let start_art =  objects[i].start_instruction.art;
					let art_index = start_art.index;
					let art = objects[i].art[art_index];
					let bank_index = art.bank[0];
					
					properties.push({
						position,
						size,
						art: {
							bank_index,
							art_index,
							style: start_art.style,
							speed: start_art.speed,
							finished_playing: false,
							animation_index: 0,
							time_to_next_change: animation_time_from_speed(start_art.speed)
						},
						travel,
						switch_state: SwitchWhen.IsOff,
						next_switch_state: SwitchWhen.IsOff,
						touched_previous_frame: [],
						done_time_triggers: []
					});
				}
				
				console.log(properties);
				
				requestAnimationFrame(() => {
					runFrame(
						{ id: game_id, length, objects, win_conditions, layers, collision_data },
						{ properties, win_status: GameCondition.NotYetWon, frame: 0, is_frozen: false },
						{ image_data, background_image }
					);
				})
			}
			
		}
	} else {
		for (let i = 0; i < event.dataTransfer.files.length; i++) {
			console.warn('Not Implemented');
		}
	}
}

let mouse = {
	x: 0,
	y: 0,
	pressed: false,
};

document.addEventListener('mousemove', handle_mouse_move, false);
document.addEventListener('mousedown', handle_mouse_down, false);
document.addEventListener('mouseup', handle_mouse_up, false)

function handle_mouse_move(event) {
	mouse.x = event.clientX - canvas.offsetLeft;
	mouse.y = event.clientY - canvas.offsetTop;
}

// TODO: Set pressed only on the first frame it is down
function handle_mouse_down(event) {
	if (event.button === 0) {
		mouse.pressed = true;
	}
}

function handle_mouse_up(event) {
	if (event.button === 0) {
		mouse.pressed = false;
	}
}

function is_triggered(state, i, trigger, game_data) {
	let has_made_contact = (props, collided) => {
		let filter_touches = (props) => {
			return props.touched_previous_frame.filter(t => t != trigger);
		};
		if (trigger.contact === ContactType.Overlap) {
			return collided;
		} else {
			if (!collided) {
				props.touched_previous_frame = filter_touches(props);
				return false;
			}
			if (props.touched_previous_frame.includes(trigger)) {
				return false;
			} else {
				props.touched_previous_frame.push(trigger);
				return true;
			}
		}
	}

	let props = state.properties[i];
	switch (trigger.tag) {
		case Trigger.TapAnywhere: {
			return mouse.pressed;
		}
		case Trigger.TapThisObject: {
			let size = props.size;
			let half_size = size / 2;
			if (mouse.pressed) {
				let pixel_x = mouse.x - props.position.x + half_size;
				let pixel_y = mouse.y - props.position.y + half_size;
				if (pixel_x < 0.0
					|| pixel_x >= size
					|| pixel_y < 0.0
					|| pixel_y >= size)
				{
					return false;
				} else {
					let bank = props.art.bank_index;
					if (bank in game_data.collision_data) {
						let index = pixel_y * size + pixel_x;
						let data = game_data.collision_data[bank];
						return data[index * COLOUR_BYTES_COUNT + 3] != 0;
					}
				}
			}
			return false;
		}
		case Trigger.TimeExact: {
			return trigger.when * 15 === state.frame;
		}
		case Trigger.TimeRandom: {
			let is_quarter = state.frame % 15 === 0;
			if (props.done_time_triggers.includes(trigger)) {
				return false;
			} else if (is_quarter) {
				let start = trigger.start;
				let end = trigger.end;
				if (trigger.end === Time.End) {
					if (game_data.length === Length.Short) {
						end = 32;
					} else {
						end = 64;
					}
				}
				let quarter = Math.floor(state.frame / 15);
				let triggered = random_in_range(Math.max(start, quarter), end + 1) === quarter;
				if (triggered) {
					props.done_time_triggers.push(trigger);
				}
				
				return triggered;
			} else {
				return false;
			}
		}
		case Trigger.Contact: {
			if (trigger.touches.what === TouchesWhat.Location) {			
				let size = props.size;
				let half_size = size / 2;
				let area = trigger.touches.area;
				let collided = false;
				if (props.position.x - half_size < area.max.x
					&& props.position.x + half_size > area.min.x
					&& props.position.y - half_size < area.max.y
					&& props.position.y + half_size > area.min.y)
				{
					for (let x = area.min.x; x < area.max.x; x++) {
						for (let y = area.min.y; y < area.max.y; y++) {
							let pixel_x = x - props.position.x + half_size;
							let pixel_y = y - props.position.y + half_size;
							let bank = props.art.bank_index;
							if (bank in game_data.collision_data) {
								let index = pixel_y * size + pixel_x;
								let data = game_data.collision_data[bank];
								if (data[index * COLOUR_BYTES_COUNT + 3] != 0) {
									collided = true;
									break;
								}
							}
						}
					}
				}
				return has_made_contact(props, collided);
			} else {
				let collided = false;
				let props = state.properties[Math.min(i, trigger.touches.index)];
				let size = props.size;
				let half_size = size / 2;
				let area_from_properties = props => {
					let size = props.size;
					let half_size = size / 2;
					return {
						min: {
							x: props.position.x - half_size,
							y: props.position.y - half_size
						},
						max: {
							x: props.position.x + half_size,
							y: props.position.y + half_size
						}
					};
				};
				let area = area_from_properties(props);
				let other_props = state.properties[Math.max(i, trigger.touches.index)];
				let other_size = other_props.size;
				let other_half_size = other_size / 2;
				let other_area = area_from_properties(other_props);
				let common_area = {
					min: {
						x: Math.floor(Math.max(area.min.x, other_area.min.x)),
						y: Math.floor(Math.max(area.min.y, other_area.min.y))
					},
					max: {
						x: Math.floor(Math.min(area.max.x, other_area.max.x)),
						y: Math.floor(Math.min(area.max.y, other_area.max.y))
					},
				};
				
				for (let x = common_area.min.x; x <= common_area.max.x; x++) {
					for (let y = common_area.min.y; y <= common_area.max.y; y++) {
						// TODO: Deduplicate
						let pixel_x = x - Math.floor(props.position.x) + half_size;
						let pixel_y = y - Math.floor(props.position.y) + half_size;
						let other_pixel_x = x - Math.floor(other_props.position.x) + other_half_size;
						let other_pixel_y = y - Math.floor(other_props.position.y) + other_half_size;
						let bank = props.art.bank_index;
						let other_bank = other_props.art.bank_index;
						if (bank in game_data.collision_data && other_bank in game_data.collision_data) {
							let index = pixel_y * size + pixel_x;
							let data = game_data.collision_data[bank];
							let pixel = data[index * COLOUR_BYTES_COUNT + 3] != 0;
							let other_index = other_pixel_y * size + other_pixel_x;
							let other_data = game_data.collision_data[other_bank];
							let other_pixel = other_data[other_index * COLOUR_BYTES_COUNT + 3] != 0;
							if (pixel && other_pixel) {
								collided = true;
								break;
							}
						}
					}
				}
				let contact = has_made_contact(props, collided);
				return contact;
			}
		}
		case Trigger.Switch: {
			let when = trigger.switch_when;
			let switch_state = state.properties[trigger.index].switch_state;
			if (when === SwitchWhen.IsOn
				&& (switch_state === SwitchWhen.IsOn
					|| switch_state === SwitchWhen.TurnsOn))
			{
				return true;
			} else if (when === SwitchWhen.IsOff
				&& (switch_state === SwitchWhen.IsOff
					|| switch_state === SwitchWhen.TurnsOff))
			{
				return true;
			} else if (when === SwitchWhen.TurnsOn
				&& switch_state === SwitchWhen.TurnsOn)
			{
				return true;
			} else if (when === SwitchWhen.TurnsOff
				&& switch_state === SwitchWhen.TurnsOff)
			{
				return true;
			} else {
				return false;
			}
		}
		case Trigger.FinishesPlaying: {
			return props.art.finished_playing;
		}
		case Trigger.SpecificArt: {
			return props.art.art_index === trigger.index;
		}
		case Trigger.GameCondition: {
			let condition = trigger.condition;
			let win_status = state.win_status;
			if (condition == GameCondition.Win
			&& win_status == GameCondition.Win)
			{
				return true;
			} else if (condition == GameCondition.Loss
				&& win_status == GameCondition.Loss)
			{
				return true;
			} else if (condition == GameCondition.HasBeenWon
				&& (win_status == GameCondition.Win
					|| win_status == GameCondition.HasBeenWon))
			{
				return true;
			} else if (condition == GameCondition.HasBeenLost
				&& (win_status == GameCondition.Loss
					|| win_status == GameCondition.HasBeenLost))
			{
				return true;
			} else if (condition == GameCondition.NotYetLost
				&& (win_status != GameCondition.Loss
					&& win_status != GameCondition.HasBeenLost))
			{
				return true;
			} else if (condition == GameCondition.NotYetWon
				&& (win_status != GameCondition.Win
					&& win_status != GameCondition.HasBeenWon))
			{
				return true;
			} else {
				return false;
			}
		}
		default: {
			console.warn('Unreachable Trigger');
		}
	}
}

let possible_directions = [
	SpecificDirection.North,
	SpecificDirection.NorthEast,
	SpecificDirection.East,
	SpecificDirection.SouthEast,
	SpecificDirection.South,
	SpecificDirection.SouthWest,
	SpecificDirection.West,
	SpecificDirection.NorthWest
];

let velocity_from_direction = (direction, speed) => {
	let diagonal_speed = speed / Math.sqrt(2);
	switch (direction) {
		case SpecificDirection.North: {
			return { x: 0, y: -speed };
		}
		case SpecificDirection.NorthEast: {
			return { x: diagonal_speed, y: -diagonal_speed };
		}
		case SpecificDirection.East: {
			return { x: speed, y: 0 };
		}
		case SpecificDirection.SouthEast: {
			return { x: diagonal_speed, y: diagonal_speed };
		}
		case SpecificDirection.South: {
			return { x: 0, y: speed };
		}
		case SpecificDirection.SouthWest: {
			return { x: -diagonal_speed, y: diagonal_speed };
		}
		case SpecificDirection.West: {
			return { x: -speed, y: 0 };
		}
		case SpecificDirection.NorthWest: {
			return { x: -diagonal_speed, y: -diagonal_speed };
		}
	}
};

function clone_position(position) {
	return { x: position.x, y: position.y };
}

function clone_area(area) {
	return { min: clone_position(area.min), max: clone_position(area.max)};
}

function apply_action(state, i, action, game_data) {
	let props = state.properties[i];
	switch (action.tag) {
		case Action.Travel: {
			switch (action.travel) {
				case Travel.GoStraight: {
					if (action.from === FromLocation.AnotherPosition) {
						props.position = clone_position(action.position);
					} else if (action.from === FromLocation.AnotherObject) {
						// TODO: Is this done from the position at the start of the frame?
						props.position = clone_position(state.properties[action.index].position);
						props.position.x += action.offset.x;
						props.position.y += action.offset.y;
					}
					let speed = value_from_speed(action.speed);
					let travel;
					if (action.direction.tag === Direction.Random) {
						let direction = random_in_array(possible_directions);
						let velocity = velocity_from_direction(direction, speed);
						travel = { tag: ActiveTravel.GoStraight, velocity };
					} else if (action.direction.tag === Direction.Specific) {
						let direction = action.direction.direction;
						let velocity = velocity_from_direction(direction, speed);
						travel = { tag: ActiveTravel.GoStraight, velocity };
					} else {
						let position = action.direction.position;
						travel = { tag: ActiveTravel.GoToPoint, position, speed };
					}
					props.travel = travel;
					return;
				}
				case Travel.Stop: {
					props.travel = { tag: ActiveTravel.Stop };
					return;
				}
				case Travel.JumpToPosition: {
					props.position = clone_position(action.position);
					props.travel = { tag: ActiveTravel.Stop };
					return;
				}
				case Travel.JumpToArea: {
					props.position = position_in_area(action.area, props.size);
					props.travel = { tag: ActiveTravel.Stop };
					return;
				}
				case Travel.JumpToObject: {
					props.position = clone_position(state.properties[action.index].position);
					props.position.x += action.offset.x;
					props.position.y += action.offset.y;
					props.travel = { tag: ActiveTravel.Stop };
					return;
				}
				case Travel.Roam: {
					let speed = value_from_speed(action.speed);
					let direction = random_in_array(possible_directions);
					let velocity = velocity_from_direction(direction, speed);
					let area = clone_area(action.area);
					let half_size = props.size / 2;
					area.min.x += half_size;
					area.min.y += half_size;
					area.max.x -= half_size;
					area.max.y -= half_size;
					let overlap = action.overlap;
					let travel;
					let roam = action.roam;
					let tag = ActiveTravel.Roam;
					if (roam === Roam.Wiggle) {
						travel = { tag, roam, area, speed, overlap };
					} else if (roam === Roam.Insect) {
						travel = { tag, roam, area, speed, overlap, velocity };
					} else if (roam === Roam.Reflect) {
						if (area.min.x < area.max.x && area.min.y < area.max.y) {
							let angle = random_in_range(0, Math.PI * 2);
							velocity = { x: speed * Math.cos(angle), y: speed & Math.sin(angle) };
						} else if (area.min.x > area.max.x) {
							velocity = { x: 0, y: speed };
						} else {
							velocity = { x: speed, y: 0 };
						}
						
						travel = { tag, roam, area, speed, overlap, velocity };
					} else if (roam === Roam.Bounce) {
						let frames_in_bounce = 60 * value_from_speed(Speed.Normal) / speed;
						let acceleration = -2 * (area.min.y - area.max.y) / (frames_in_bounce * frames_in_bounce);
						let velocity = {
							x: 0,
							y: 2 * (area.min.y - props.position.y) / frames_in_bounce
						};
						travel = { tag, roam, area, speed, overlap, velocity, acceleration, frames_in_bounce };
					}
					props.travel = travel;
					return;
				}
				case Travel.Swap: {
					let temp = clone_position(props.position);
					props.position = clone_position(state.properties[action.index]);
					state.properties[action.index].position = temp;
					return;
				}
				case Travel.Target: {
					let index = action.index;
					let offset = action.offset;
					let speed = value_from_speed(speed);
					props.travel = { tag: ActiveTravel.GoToObject, index, offset, speed };
					return;
				}
				default: {
					console.warn('Unreachable Travel', action.travel);
					return;
				}
			}
		}
		case Action.Switch: {
			let new_switch;
			if (action.switch_to === Switch.Off) {
				new_switch = SwitchWhen.TurnsOff;
			} else {
				new_switch = SwitchWhen.TurnsOn;
			}
			props.next_switch_state = new_switch;
			return;
		}
		case Action.Lose: {
			console.log('Lose Action Applied. win_status before: {:?}', state.win_status);
			if (state.win_status != GameCondition.Win
				&& state.win_status != GameCondition.Loss
				&& state.win_status != GameCondition.HasBeenWon)
			{
				state.win_status = GameCondition.Loss;
			}
			return;
		}
		case Action.StopPlaying: {
			props.art.style = AnimationStyle.Hold;
			return;
		}
		case Action.ChangeArt: {
			props.art.art_index = action.index;
			let art = game_data.objects[i].art[action.index];
			let bank = art.bank[0];
			props.art.bank_index = bank;
			props.animation_index = 0;
			props.finished_playing = false;
			props.time_to_next_change = animation_time_from_speed(action.speed);
			props.art.speed = action.speed;
			props.art.style = action.style;
			return;
		}
		case Action.SoundEffect: {
			// TODO: Ignored
			return;
		}
		case Action.ScreenEffect: {
			// TODO: Implement others
			if (action.effect === ScreenEffect.Freeze) {
				state.is_frozen = true;
			}
			return;
		}
	}
}

function runFrame(game_data, state, assets) {
	if (game_data.id !== game_id) {
		return;
	}
	let old_win_status = state.win_status;
	let triggered_actions = [];
	
	if (!state.is_frozen) {
		for (let i = 0; i < game_data.objects.length; i++) {
			triggered_actions.push([]);
			if (game_data.objects[i] === null) continue;
			let object = game_data.objects[i];
			for (let ins = 0; ins < object.instructions.length; ins++) {
				let triggered = object.instructions[ins].triggers.every(trigger => is_triggered(state, i, trigger, game_data));
				if (triggered) {
					let actions = object.instructions[ins].actions;
					triggered_actions[i] = triggered_actions[i].concat(actions);
				}
			}
		}
		
		for (let i = 0; i < triggered_actions.length; i++) {
			triggered_actions[i].forEach(action => apply_action(state, i, action, game_data));
		}
		
		for (let i = 0; i < game_data.objects.length; i++) {
			if (game_data.objects[i] === null) continue;
			let object = game_data.objects[i];
			let props = state.properties[i];
			
			let art = object.art[props.art.art_index]
			let animation_index = props.art.animation_index;
			animation_index++;
			animation_index %= art.bank.length;
			
			let bank = art.bank[animation_index];
			
			props.art.finished_playing = false;
			
			let go_to_next_image = props => {
				props.art.animation_index = animation_index;
				props.art.bank_index = bank;
				props.art.time_to_next_change = animation_time_from_speed(props.art.speed);
			};
			
			if (props.art.style !== AnimationStyle.Hold && props.art.time_to_next_change === 0) {
				if (animation_index === 0) {
					if (props.art.style === AnimationStyle.Loop) {
						go_to_next_image(props);
					} else if (props.art.style === AnimationStyle.PlayOnce) {
						props.art.style = AnimationStyle.Hold;
						props.art.finished_playing = true;
					}
				} else {
					go_to_next_image(props);
				}
			}
			
			if (props.art.style !== AnimationStyle.Hold) {
				props.art.time_to_next_change--;
			}
		}
		
		for (let i = 0; i < game_data.objects.length; i++) {
			if (game_data.objects[i] === null) continue;
			let props = state.properties[i];
			let travel = props.travel;
			
			let go_to = (props, position) => {
				let target_vector = { x: position.x - props.position.x, y: position.y - props.position.y };
				let d = Math.sqrt(Math.pow(target_vector.x) + Math.pow(target_vector.y));
				let velocity = {
					x: target_vector.x / d * travel.speed,
					y: target_vector.y / d * travel.speed
				};
				let move_to = (x, other, velocity) => {
					if (Math.abs(x - other) > Math.abs(velocity)) {
						return x + velocity;
					} else {
						return other;
					}
				};
				props.position = {
					x: move_to(props.position.x, position.x, velocity.x),
					y: move_to(props.position.y, position.y, velocity.y)
				};
			};
			
			switch (travel.tag) {
				case ActiveTravel.GoStraight: {
					props.position.x += travel.velocity.x;
					props.position.y += travel.velocity.y;
					break;
				}
				case ActiveTravel.GoToPoint: {
					let position = clone_position(travel.position);
					go_to(props, position);
					break;
				}
				case ActiveTravel.GoToObject: {
					let position = clone_position(state.properties[travel.index].position);
					position.x += travel.offset.x;
					position.y += travel.offset.y;
					go_to(props, position);
					break;
				}
				case ActiveTravel.AttachTo: {
					let position = clone_position(state.properties[travel.index].position);
					position.x += travel.offset.x;
					position.y += travel.offset.y;
					props.position = position;
					break;
				}
				case ActiveTravel.Roam: {
					if (travel.roam === Roam.Wiggle) {
						let direction = random_in_array(possible_directions);
						let velocity = velocity_from_direction(direction, travel.speed);
						props.position.x += velocity.x;
						props.position.y += velocity.y;
					} else if (travel.roam === Roam.Insect) {
						const CHANGE_DIRECTION_PROBABILTY = 0.1;
						if (random_in_range(0, 1) < CHANGE_DIRECTION_PROBABILTY) {
							let direction = random_in_array(possible_directions);
							travel.velocity = velocity_from_direction(direction, travel.speed);
						}
						props.position.x += travel.velocity.x;
						props.position.y += travel.velocity.y;
					} else if (travel.roam === Roam.Reflect) {
						let area = travel.area;
						// TODO: Subtract size from area
						if (props.position.x + travel.velocity.x < area.min.x) {
							travel.velocity.x = Math.abs(travel.velocity.x);
						}
						if (props.position.x + travel.velocity.x > area.max.x) {
							travel.velocity.x = -Math.abs(travel.velocity.x);
						}
						if (props.position.y + travel.velocity.y < area.min.y) {
							travel.velocity.y = Math.abs(travel.velocity.y);
						}
						if (props.position.y + travel.velocity.y > area.max.y) {
							travel.velocity.y = -Math.abs(travel.velocity.y);
						}
						props.position.x += travel.velocity.x;
						props.position.y += travel.velocity.y;
					} else if (travel.roam === Roam.Bounce) {
						let area = travel.area;
						if (props.position.y < area.min.y && travel.velocity.y < 0.0) {
							travel.velocity.y = 0.0;
						}
						if (props.position.y < area.max.y) {
							travel.velocity.y += travel.acceleration;
						} else if (props.position.y > area.max.y) {
							travel.velocity.y = -travel.acceleration * travel.frames_in_bounce;
						}
					}
					break;
				}
			}
			
		}
		
		for (let i = 0; i < game_data.objects.length; i++) {
			if (game_data.objects[i] === null) continue;
			let props = state.properties[i];
			if (props.switch_state === SwitchWhen.TurnsOff) {
				props.switch_state = SwitchWhen.IsOff;
			} else if (props.switch_state === SwitchWhen.TurnsOn) {
				props.switch_state = SwitchWhen.IsOn;
			}
			if (props.next_switch_state === SwitchWhen.TurnsOn && props.switch_state === SwitchWhen.IsOff) {
				props.switch_state = SwitchWhen.TurnsOn;
			}
			if (props.next_switch_state === SwitchWhen.TurnsOff && props.switch_state === SwitchWhen.IsOn) {
				props.switch_state = SwitchWhen.TurnsOff;
			}
		}
		
		if (GameCondition.Win == old_win_status) {
			state.win_status = GameCondition.HasBeenWon;
		} else if (GameCondition.Loss == old_win_status) {
			state.win_status = GameCondition.HasBeenLost;
		}
		
		if (state.win_status == GameCondition.NotYetWon) {
			for (let condition_index = 0; condition_index < game_data.win_conditions.length; condition_index++) {
				let conditions = game_data.win_conditions[condition_index];
				let won = null;
				for (let which = 0; which < conditions.length; which++) {
					let win_condition = conditions[which];
					let switch_when = win_condition.switch_state;
					let props = state.properties[win_condition.index];
					let same;
					if (switch_when == Switch.On
						&& (props.switch_state == SwitchWhen.IsOn
							|| props.switch_state == SwitchWhen.TurnsOn))
					{
						same = true;
					} else if (switch_when == Switch.Off
						&& (props.switch_state == SwitchWhen.IsOff
							|| props.switch_state == SwitchWhen.TurnsOff))
					{
						same = true;
					} else {
						same = false;
					};
					if (won !== null) {
						won = won && same;
					} else {
						won = same;
					}
				}
				
				if (won === true) {
					console.log('Game Won');
					state.win_status = GameCondition.Win;
				}
			}
		}
	}
	
	if (state.is_frozen) {
		context.filter = 'invert(1)';
	} else {
		context.filter = 'none';
	}
	context.drawImage(assets.background_image, 0, 0);
	
	let layer_count = Math.min(game_data.layers.length, state.properties.length);
	
	for (let layer = 0; layer < layer_count; layer++) {
		let i = game_data.layers[layer];
		let props = state.properties[i];
		if (props !== null) {
			let size = props.size;
			let half_size = size / 2;
			let bank = props.art.bank_index;
			let image = assets.image_data[bank];
			let position = props.position;
			context.drawImage(image, position.x - half_size, position.y - half_size);
		}
	}
	
	state.frame++;

	requestAnimationFrame(() => {
		runFrame(game_data, state, assets);
	})
}

function dragOverHandler(event) {
	console.log('Drag');
	event.preventDefault();
}
</script>


</body>
</html>
